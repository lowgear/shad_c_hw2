
Реализуйте свою императивную машину, т.е. ПО, умеющее исполнять ассемблерные инструкции и оперирующее регистрами, стеком, памятью и командами.
 
Регистры: 8 регистров общего назначения — R0X, R1X, ..., R6X и SP (синоним R7X). Регистр IP не нужно делать непосредственно доступным из инструкций. Ширина регистра 16, должно быть можно обращаться к половинкам регистров (R0L (low), R0H (high), R1L, ...), их ширина, соответственно, 8. Регистр флагов не требуется.
 
Память адресуется 15 битами, младший бит нулевой. Стек, программа и данные лежат в одном адресном пространстве. В т.ч. это означает, что теоретически можно поменять любую операцию программы прямо в ходе выполнения программы, в т.ч. текущую исполняемую (в этом случае выполнение программы продолжится штатно, если дальше, например, в цикле, отредактированная операция встретится снова, исполнится уже её отредактированная версия). Один фрейм стека — 2 байта.
 
Обозначения:
RX — 16-битный регистр (R0X, R1X, ...)
RS — 8-битная половинка (R0H, R0L, R1H, ...)
RiX — i-ый 16-битный регистр
RiS — i-ый 8-битный регистр
imm8 — 8-битный immediate, константа
imm4 — 4-битный immediate, константа
 
Команды ассемблера:

 1 0000_ 3+3 mov RX, RX
 2 0001_ 3+3 mov RX, (RX)
 3 0010_ 3+3 mov (RX), RX
 4 0011_ 4+8 mov RS, #imm8
 5 0100_ 3   push RX         - положить значение регистра на стек (в т.ч. можно R7X, он же SP, тогда сначала его значение уменьшится, а затем уже уменьшенное положится по адресу, который в нём лежит в качестве значения)
 6 0101_ 3   pop RX          - взять со стека значение и положить в регистр
 7 0110_ 8   call #imm8      - relative call от текущей инструкции на знаковый imm8 (внутреннее представление — дополнительный код, значения [-128, 127], на стек кладётся адрес следующей инструкции для ret)
 8 01110 0   ret             - вернуться к команде после последнего вызова
 9 01111 3+3 add RX RX       - положить в первый операнд сумму обоих операндов
10 10000 3+3 sub RX RX       - положить в первый операнд значение первый операнд минус второй операнд; операции все над беззнаковыми интами по модулю 2^16 (как беззнаковый int в C)
11 10001 3+3 mul RX RX
12 10010 3+3 div RX RX
13 10011 3+3 and RX RX
14 10100 3+3 or RX RX
15 10101 3+3 xor RX RX
16 10110 3   not RX
17 10111 3+4 shl RX #imm4    - положить в RX значение (RX << imm4)
18 11000 3+4 shr RX #imm4
19 11001     reset           - выход с кодом возврата, лежащим в R0L
20 11010     nop             - пустая операция
21 11011 8   jmp <label>     - безусловный переход от текущей инструкции к метке. Под капотом должен быть relative переход на знаковый imm8 (как в call) от текущей инструкции до места встречи метки, это всё должно вычисляться на этапе интерпретации; если в imm8 не влезает расстояние между jmp и меткой — ошибка ассебмлирования.
22 11100 8+3 je метка RX     - то же, что в предыдущем, но условный; je перейдёт, если в RX 0, jne — если не 0
23 11101 8+3 jne метка RX    - то же, что в предыдущем, но условный; je перейдёт, если в RX 0, jne — если не 0
24 11110 4   in RS           - читает 1 байт со стандартного ввода, пишет на половинчатый регистр
25 11111 4   out RS          - выводит на стандартный вывод 1 байт содержимого половинчатого регистра
 
Кроме команд
<label>:— метка с именем label
Секции не нужны
Комментарии по желанию