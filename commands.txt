
Реализуйте свою императивную машину, т.е. ПО, умеющее исполнять ассемблерные инструкции и оперирующее регистрами, стеком, памятью и командами.
 
Регистры: 8 регистров общего назначения — R0X, R1X, ..., R6X и SP (синоним R7X). Регистр IP не нужно делать непосредственно доступным из инструкций. Ширина регистра 16, должно быть можно обращаться к половинкам регистров (R0L (low), R0H (high), R1L, ...), их ширина, соответственно, 8. Регистр флагов не требуется.
 
Память адресуется 15 битами, младший бит нулевой. Стек, программа и данные лежат в одном адресном пространстве. В т.ч. это означает, что теоретически можно поменять любую операцию программы прямо в ходе выполнения программы, в т.ч. текущую исполняемую (в этом случае выполнение программы продолжится штатно, если дальше, например, в цикле, отредактированная операция встретится снова, исполнится уже её отредактированная версия). Один фрейм стека — 2 байта.
 
Обозначения:
RX — 16-битный регистр (R0X, R1X, ...)
RS — 8-битная половинка (R0H, R0L, R1H, ...)
RiX — i-ый 16-битный регистр
RiS — i-ый 8-битный регистр
imm8 — 8-битный immediate, константа
imm4 — 4-битный immediate, константа
 
Команды ассемблера:

1 3+3 mov <dst> <src>
2 3+3 mov RX, RX
3 3+3 mov RX, (RX)
4 3+3 mov (RX), RX
5 4+8 mov RS, #imm8
6 3 push RX
	положить значение регистра на стек (в т.ч. можно R7X, он же SP, тогда сначала его значение уменьшится, а затем уже уменьшенное положится по адресу, который в нём лежит в качестве значения)
7 3 pop RX
	взять со стека значение и положить в регистр
8 8 call imm8
	relative call от текущей инструкции на знаковый imm8 (внутреннее представление — дополнительный код, значения [-128, 127], на стек кладётся адрес следующей инструкции для ret)
9 ret
	вернуться к команде после последнего вызова
10 3+3 add RX RX
	положить в первый операнд сумму обоих операндов
11 3+3 sub RX RX
	положить в первый операнд значение первый операнд минус второй операнд; операции все над беззнаковыми интами по модулю 2^16 (как беззнаковый int в C)
12 3+3 mul RX RX 
13 3+3 div RX RX 
14 3+3 and RX RX 
15 3+3 or RX RX 
16 3+3 xor RX RX 
17 3 not RX 
18 3+4 shl RX #imm4
	положить в RX значение (RX << imm4)
19 3+4 shr RX #imm4 
20 reset
	выход с кодом возврата, лежащим в R0L
21 nop
	пустая операция
22 4 jmp <label>
	безусловный переход от текущей инструкции к метке. Под капотом должен быть relative переход на знаковый imm8 (как в call) от текущей инструкции до места встречи метки, это всё должно вычисляться на этапе интерпретации; если в imm8 не влезает расстояние между jmp и меткой — ошибка ассебмлирования.
23 4+3 je/jne метка RX
	то же, что в предыдущем, но условный; je перейдёт, если в RX 0, jne — если не 0
24 4 in RS
	читает 1 байт со стандартного ввода, пишет на половинчатый регистр
25 4 out RS
	выводит на стандартный вывод 1 байт содержимого половинчатого регистра
 
Кроме команд
<label>:— метка с именем label
Секции не нужны
Комментарии по желанию